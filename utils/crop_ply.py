#!/usr/bin/env python3

import argparse
import json
import math
import os
import struct
import sys
from typing import List, Tuple


PLY_TYPE_TO_STRUCT = {
    "char": "b",
    "uchar": "B",
    "int8": "b",
    "uint8": "B",
    "short": "h",
    "ushort": "H",
    "int16": "h",
    "uint16": "H",
    "int": "i",
    "int32": "i",
    "uint": "I",
    "uint32": "I",
    "float": "f",
    "float32": "f",
    "double": "d",
    "float64": "d",
}


def read_preset(preset_path: str):
    with open(preset_path, "r", encoding="utf-8") as f:
        data = json.load(f)

    crop = data.get("crop", data)
    try:
        xmin = float(crop["xmin"])
        xmax = float(crop["xmax"])
        ymin = float(crop["ymin"])
        ymax = float(crop["ymax"])
        zmin = float(crop["zmin"])
        zmax = float(crop["zmax"])
    except (KeyError, TypeError, ValueError):
        raise SystemExit("Error: preset JSON must contain crop.xmin..zmax values.")

    invert_crop = bool(data.get("invertCrop", False))

    custom_planes = data.get("customPlanes", [])

    return (xmin, xmax, ymin, ymax, zmin, zmax), invert_crop, custom_planes


def parse_ply_header(f):
    """
    Parse a minimal PLY header.
    Returns: (format_type, vertex_count, vertex_props, header_end_offset)
    - format_type: 'ascii' or 'binary_little_endian'
    - vertex_props: list of (name, type_str)
    """
    first = f.readline()
    if not first.startswith(b"ply"):
        raise SystemExit("Error: not a PLY file (missing 'ply' header).")

    vertex_count = None
    vertex_props: List[Tuple[str, str]] = []
    format_type = None
    in_vertex = False

    while True:
        line_bytes = f.readline()
        if not line_bytes:
            raise SystemExit("Error: unexpected EOF while reading PLY header.")
        line = line_bytes.decode("ascii", errors="ignore").strip()
        if line == "end_header":
            break
        if not line:
            continue
        tokens = line.split()
        if tokens[0] == "format":
            if len(tokens) < 2:
                raise SystemExit("Error: malformed format line in PLY header.")
            format_type = tokens[1]
        elif tokens[0] == "element":
            in_vertex = tokens[1] == "vertex"
            if in_vertex:
                if len(tokens) < 3:
                    raise SystemExit("Error: malformed element vertex line.")
                vertex_count = int(tokens[2])
        elif tokens[0] == "property" and in_vertex:
            if len(tokens) < 3:
                raise SystemExit("Error: malformed property line for vertex.")
            if tokens[1] == "list":
                raise SystemExit("Error: list properties on vertex are not supported.")
            p_type = tokens[1]
            p_name = tokens[2]
            vertex_props.append((p_name, p_type))

    header_end = f.tell()

    if format_type is None:
        raise SystemExit("Error: PLY format line not found.")
    if vertex_count is None:
        raise SystemExit("Error: PLY element vertex not found.")

    if format_type not in ("ascii", "binary_little_endian"):
        raise SystemExit(f"Error: unsupported PLY format '{format_type}'.")

    return format_type, vertex_count, vertex_props, header_end


def build_output_header(format_type: str, vertex_props, vertex_count: int) -> str:
    lines = []
    lines.append("ply")
    if format_type == "ascii":
        lines.append("format ascii 1.0")
    else:
        lines.append("format binary_little_endian 1.0")
    lines.append("comment generated by crop_ply.py")
    lines.append(f"element vertex {vertex_count}")
    for name, p_type in vertex_props:
        lines.append(f"property {p_type} {name}")
    lines.append("end_header")
    return "\n".join(lines) + "\n"


def _compute_plane_normals_and_points(custom_planes, crop_bounds):
    xmin, xmax, ymin, ymax, zmin, zmax = crop_bounds
    cx = 0.5 * (xmin + xmax)
    cy = 0.5 * (ymin + ymax)
    cz = 0.5 * (zmin + zmax)

    normals: List[Tuple[float, float, float]] = []
    points: List[Tuple[float, float, float]] = []
    for plane in custom_planes:
        yaw_deg = float(plane.get("yaw", 0.0))
        pitch_deg = float(plane.get("pitch", 0.0))
        yaw = math.radians(yaw_deg)
        pitch = math.radians(pitch_deg)
        nx = math.sin(yaw) * math.cos(pitch)
        ny = math.sin(pitch)
        nz = math.cos(yaw) * math.cos(pitch)
        length = math.sqrt(nx * nx + ny * ny + nz * nz)
        if length == 0:
            nx, ny, nz = 0.0, 0.0, 1.0
            length = 1.0
        nx /= length
        ny /= length
        nz /= length
        normals.append((nx, ny, nz))

        px = plane.get("px")
        py = plane.get("py")
        pz = plane.get("pz")
        if px is None or py is None or pz is None:
            px, py, pz = cx, cy, cz
        points.append((float(px), float(py), float(pz)))

    return normals, points


def crop_ascii_ply(
    in_path: str,
    out_path: str,
    crop_bounds,
    invert_crop: bool = False,
    custom_planes=None,
):
    xmin, xmax, ymin, ymax, zmin, zmax = crop_bounds
    custom_planes = custom_planes or []
    use_custom = bool(custom_planes)

    # First pass: if custom planes exist, determine smallest region key.
    selected_key = None
    normals: List[Tuple[float, float, float]] = []
    center = (0.0, 0.0, 0.0)

    if use_custom:
        with open(in_path, "rb") as f:
            format_type, vertex_count, vertex_props, header_end = parse_ply_header(f)
            if format_type != "ascii":
                raise SystemExit("Internal error: crop_ascii_ply called for non-ascii file.")

            name_to_index = {name: i for i, (name, _) in enumerate(vertex_props)}
            try:
                ix = name_to_index["x"]
                iy = name_to_index["y"]
                iz = name_to_index["z"]
            except KeyError:
                raise SystemExit("Error: vertex properties must include x, y, z.")

            normals, plane_points = _compute_plane_normals_and_points(
                custom_planes, crop_bounds
            )
            plane_count = len(normals)
            plane_dots = [
                nx * px + ny * py + nz * pz
                for (nx, ny, nz), (px, py, pz) in zip(normals, plane_points)
            ]

            region_map = {}

            for _ in range(vertex_count):
                line_bytes = f.readline()
                if not line_bytes:
                    raise SystemExit(
                        "Error: unexpected EOF while reading ascii vertex data."
                    )
                line_str = line_bytes.decode("ascii", errors="ignore").strip()
                if not line_str:
                    continue
                tokens = line_str.split()
                if len(tokens) <= max(ix, iy, iz):
                    continue
                try:
                    x = float(tokens[ix])
                    y = float(tokens[iy])
                    z = float(tokens[iz])
                except ValueError:
                    continue
                inside_box = (
                    xmin <= x <= xmax
                    and ymin <= y <= ymax
                    and zmin <= z <= zmax
                )
                if not inside_box:
                    continue

                key_chars = []
                for (nx, ny, nz), p_dot in zip(normals, plane_dots):
                    d = nx * x + ny * y + nz * z - p_dot
                    key_chars.append("1" if d >= 0 else "0")
                key = "".join(key_chars)

                region = region_map.get(key)
                if region is None:
                    region = {
                        "min": [x, y, z],
                        "max": [x, y, z],
                        "count": 0,
                    }
                    region_map[key] = region
                else:
                    mn = region["min"]
                    mx = region["max"]
                    mn[0] = min(mn[0], x)
                    mn[1] = min(mn[1], y)
                    mn[2] = min(mn[2], z)
                    mx[0] = max(mx[0], x)
                    mx[1] = max(mx[1], y)
                    mx[2] = max(mx[2], z)
                region["count"] += 1

        if region_map:
            best_key = None
            best_region = None
            best_score = -float("inf")
            best_count = -float("inf")
            for key, region in region_map.items():
                mn = region["min"]
                mx = region["max"]
                intersect_count = 0
                for (nx, ny, nz), p_dot in zip(normals, plane_dots):
                    min_dot = float("inf")
                    max_dot = -float("inf")
                    for x in (mn[0], mx[0]):
                        for y in (mn[1], mx[1]):
                            for z in (mn[2], mx[2]):
                                d = nx * x + ny * y + nz * z
                                if d < min_dot:
                                    min_dot = d
                                if d > max_dot:
                                    max_dot = d
                    if min_dot <= p_dot <= max_dot:
                        intersect_count += 1

                score = intersect_count
                if score > best_score or (score == best_score and region["count"] > best_count):
                    best_score = score
                    best_count = region["count"]
                    best_key = key
                    best_region = region

            selected_key = best_key
        else:
            # No region inside the box; treat as if there are no custom planes.
            use_custom = False

    # Second pass: perform actual cropping.
    with open(in_path, "rb") as f:
        format_type, vertex_count, vertex_props, header_end = parse_ply_header(f)
        if format_type != "ascii":
            raise SystemExit("Internal error: crop_ascii_ply called for non-ascii file.")

        name_to_index = {name: i for i, (name, _) in enumerate(vertex_props)}
        try:
            ix = name_to_index["x"]
            iy = name_to_index["y"]
            iz = name_to_index["z"]
        except KeyError:
            raise SystemExit("Error: vertex properties must include x, y, z.")

        normals, plane_points = _compute_plane_normals_and_points(
            custom_planes, crop_bounds
        )
        plane_dots = [
            nx * px + ny * py + nz * pz
            for (nx, ny, nz), (px, py, pz) in zip(normals, plane_points)
        ]

        kept_lines = []
        for _ in range(vertex_count):
            line_bytes = f.readline()
            if not line_bytes:
                raise SystemExit(
                    "Error: unexpected EOF while reading ascii vertex data."
                )
            line_str = line_bytes.decode("ascii", errors="ignore").strip()
            if not line_str:
                continue
            tokens = line_str.split()
            if len(tokens) <= max(ix, iy, iz):
                continue
            try:
                x = float(tokens[ix])
                y = float(tokens[iy])
                z = float(tokens[iz])
            except ValueError:
                continue

            inside_box = (
                xmin <= x <= xmax
                and ymin <= y <= ymax
                and zmin <= z <= zmax
            )

            if use_custom and selected_key is not None and normals:
                is_selected = False
                if inside_box:
                    key_chars = []
                    for (nx, ny, nz), p_dot in zip(normals, plane_dots):
                        d = nx * x + ny * y + nz * z - p_dot
                        key_chars.append("1" if d >= 0 else "0")
                    key = "".join(key_chars)
                    is_selected = key == selected_key
                keep = not is_selected if invert_crop else is_selected
            else:
                keep = inside_box if not invert_crop else not inside_box

            if keep:
                kept_lines.append(line_str)

    out_header = build_output_header("ascii", vertex_props, len(kept_lines))
    with open(out_path, "w", encoding="ascii") as g:
        g.write(out_header)
        for line in kept_lines:
            g.write(line + "\n")


def crop_binary_ply(
    in_path: str,
    out_path: str,
    crop_bounds,
    invert_crop: bool = False,
    custom_planes=None,
):
    xmin, xmax, ymin, ymax, zmin, zmax = crop_bounds
    custom_planes = custom_planes or []
    use_custom = bool(custom_planes)

    selected_key = None
    normals: List[Tuple[float, float, float]] = []
    center = (0.0, 0.0, 0.0)

    # First pass for smallest region key when we have custom planes.
    if use_custom:
        with open(in_path, "rb") as f:
            format_type, vertex_count, vertex_props, header_end = parse_ply_header(f)
            if format_type != "binary_little_endian":
                raise SystemExit(
                    "Internal error: crop_binary_ply called for non-binary file."
                )

            fmt_parts = []
            for name, p_type in vertex_props:
                if p_type not in PLY_TYPE_TO_STRUCT:
                    raise SystemExit(f"Error: unsupported PLY data type '{p_type}'.")
                fmt_parts.append(PLY_TYPE_TO_STRUCT[p_type])
            struct_fmt = "<" + "".join(fmt_parts)
            rec_size = struct.calcsize(struct_fmt)

            name_to_index = {name: i for i, (name, _) in enumerate(vertex_props)}
            try:
                ix = name_to_index["x"]
                iy = name_to_index["y"]
                iz = name_to_index["z"]
            except KeyError:
                raise SystemExit("Error: vertex properties must include x, y, z.")

            normals, plane_points = _compute_plane_normals_and_points(
                custom_planes, crop_bounds
            )
            plane_count = len(normals)
            plane_dots = [
                nx * px + ny * py + nz * pz
                for (nx, ny, nz), (px, py, pz) in zip(normals, plane_points)
            ]

            region_map = {}

            for _ in range(vertex_count):
                rec = f.read(rec_size)
                if len(rec) != rec_size:
                    raise SystemExit(
                        "Error: unexpected EOF while reading binary vertex data."
                    )
                values = struct.unpack(struct_fmt, rec)
                x = float(values[ix])
                y = float(values[iy])
                z = float(values[iz])

                inside_box = (
                    xmin <= x <= xmax
                    and ymin <= y <= ymax
                    and zmin <= z <= zmax
                )
                if not inside_box:
                    continue

                key_chars = []
                for (nx, ny, nz), p_dot in zip(normals, plane_dots):
                    d = nx * x + ny * y + nz * z - p_dot
                    key_chars.append("1" if d >= 0 else "0")
                key = "".join(key_chars)

                region = region_map.get(key)
                if region is None:
                    region = {
                        "min": [x, y, z],
                        "max": [x, y, z],
                        "count": 0,
                    }
                    region_map[key] = region
                else:
                    mn = region["min"]
                    mx = region["max"]
                    mn[0] = min(mn[0], x)
                    mn[1] = min(mn[1], y)
                    mn[2] = min(mn[2], z)
                    mx[0] = max(mx[0], x)
                    mx[1] = max(mx[1], y)
                    mx[2] = max(mx[2], z)
                region["count"] += 1

        if region_map:
            best_key = None
            best_region = None
            best_score = -float("inf")
            best_count = -float("inf")
            for key, region in region_map.items():
                mn = region["min"]
                mx = region["max"]
                intersect_count = 0
                for (nx, ny, nz), p_dot in zip(normals, plane_dots):
                    min_dot = float("inf")
                    max_dot = -float("inf")
                    for x in (mn[0], mx[0]):
                        for y in (mn[1], mx[1]):
                            for z in (mn[2], mx[2]):
                                d = nx * x + ny * y + nz * z
                                if d < min_dot:
                                    min_dot = d
                                if d > max_dot:
                                    max_dot = d
                    if min_dot <= p_dot <= max_dot:
                        intersect_count += 1

                score = intersect_count
                if score > best_score or (score == best_score and region["count"] > best_count):
                    best_score = score
                    best_count = region["count"]
                    best_key = key
                    best_region = region

            selected_key = best_key
        else:
            use_custom = False

    # Second pass: crop and write.
    with open(in_path, "rb") as f:
        format_type, vertex_count, vertex_props, header_end = parse_ply_header(f)
        if format_type != "binary_little_endian":
            raise SystemExit(
                "Internal error: crop_binary_ply called for non-binary file."
            )

        fmt_parts = []
        for name, p_type in vertex_props:
            if p_type not in PLY_TYPE_TO_STRUCT:
                raise SystemExit(f"Error: unsupported PLY data type '{p_type}'.")
            fmt_parts.append(PLY_TYPE_TO_STRUCT[p_type])
        struct_fmt = "<" + "".join(fmt_parts)
        rec_size = struct.calcsize(struct_fmt)

        name_to_index = {name: i for i, (name, _) in enumerate(vertex_props)}
        try:
            ix = name_to_index["x"]
            iy = name_to_index["y"]
            iz = name_to_index["z"]
        except KeyError:
            raise SystemExit("Error: vertex properties must include x, y, z.")

        normals, plane_points = _compute_plane_normals_and_points(
            custom_planes, crop_bounds
        )
        plane_dots = [
            nx * px + ny * py + nz * pz
            for (nx, ny, nz), (px, py, pz) in zip(normals, plane_points)
        ]

        kept_records = []
        for _ in range(vertex_count):
            rec = f.read(rec_size)
            if len(rec) != rec_size:
                raise SystemExit(
                    "Error: unexpected EOF while reading binary vertex data."
                )
            values = struct.unpack(struct_fmt, rec)
            x = float(values[ix])
            y = float(values[iy])
            z = float(values[iz])

            inside_box = (
                xmin <= x <= xmax
                and ymin <= y <= ymax
                and zmin <= z <= zmax
            )

            if use_custom and selected_key is not None and normals:
                is_selected = False
                if inside_box:
                    key_chars = []
                    for (nx, ny, nz), p_dot in zip(normals, plane_dots):
                        d = nx * x + ny * y + nz * z - p_dot
                        key_chars.append("1" if d >= 0 else "0")
                    key = "".join(key_chars)
                    is_selected = key == selected_key
                keep = not is_selected if invert_crop else is_selected
            else:
                keep = inside_box if not invert_crop else not inside_box

            if keep:
                kept_records.append(rec)

    out_header = build_output_header("binary_little_endian", vertex_props, len(kept_records))
    with open(out_path, "wb") as g:
        g.write(out_header.encode("ascii"))
        for rec in kept_records:
            g.write(rec)


def main(argv=None):
    parser = argparse.ArgumentParser(
        description="Crop a PLY point cloud using a preset.json generated by the web app."
    )
    parser.add_argument("--ply", required=True, help="Input PLY file path.")
    parser.add_argument("--preset", required=True, help="preset.json file path.")
    parser.add_argument(
        "--out",
        help="Output PLY path. If omitted, 'cropped_<input_basename>.ply' is used.",
    )
    args = parser.parse_args(argv)

    ply_path = args.ply
    preset_path = args.preset
    if not os.path.isfile(ply_path):
        raise SystemExit(f"Error: PLY file not found: {ply_path}")
    if not os.path.isfile(preset_path):
        raise SystemExit(f"Error: preset file not found: {preset_path}")

    crop_bounds, invert_crop, custom_planes = read_preset(preset_path)

    with open(ply_path, "rb") as f:
        format_type, vertex_count, vertex_props, header_end = parse_ply_header(f)

    if args.out:
        out_path = args.out
    else:
        base = os.path.basename(ply_path)
        root, ext = os.path.splitext(base)
        if not ext:
            ext = ".ply"
        out_path = os.path.join(os.path.dirname(ply_path), f"cropped_{root}{ext}")

    if format_type == "ascii":
        crop_ascii_ply(
            ply_path,
            out_path,
            crop_bounds,
            invert_crop=invert_crop,
            custom_planes=custom_planes,
        )
    elif format_type == "binary_little_endian":
        crop_binary_ply(
            ply_path,
            out_path,
            crop_bounds,
            invert_crop=invert_crop,
            custom_planes=custom_planes,
        )
    else:
        raise SystemExit(f"Error: unsupported PLY format '{format_type}'.")

    print(f"Written cropped PLY: {out_path}")


if __name__ == "__main__":
    main()
