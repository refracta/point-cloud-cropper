#!/usr/bin/env python3

import argparse
import json
import os
import struct
import sys
from typing import List, Tuple


PLY_TYPE_TO_STRUCT = {
    "char": "b",
    "uchar": "B",
    "int8": "b",
    "uint8": "B",
    "short": "h",
    "ushort": "H",
    "int16": "h",
    "uint16": "H",
    "int": "i",
    "int32": "i",
    "uint": "I",
    "uint32": "I",
    "float": "f",
    "float32": "f",
    "double": "d",
    "float64": "d",
}


def read_preset(preset_path: str):
    with open(preset_path, "r", encoding="utf-8") as f:
        data = json.load(f)

    crop = data.get("crop", data)
    try:
        xmin = float(crop["xmin"])
        xmax = float(crop["xmax"])
        ymin = float(crop["ymin"])
        ymax = float(crop["ymax"])
        zmin = float(crop["zmin"])
        zmax = float(crop["zmax"])
    except (KeyError, TypeError, ValueError):
        raise SystemExit("Error: preset JSON must contain crop.xmin..zmax values.")

    invert_crop = bool(data.get("invertCrop", False))

    # customPlanes are optional and currently ignored by this CLI.
    custom_planes = data.get("customPlanes", [])

    return (xmin, xmax, ymin, ymax, zmin, zmax), invert_crop, custom_planes


def parse_ply_header(f):
    """
    Parse a minimal PLY header.
    Returns: (format_type, vertex_count, vertex_props, header_end_offset)
    - format_type: 'ascii' or 'binary_little_endian'
    - vertex_props: list of (name, type_str)
    """
    first = f.readline()
    if not first.startswith(b"ply"):
        raise SystemExit("Error: not a PLY file (missing 'ply' header).")

    vertex_count = None
    vertex_props: List[Tuple[str, str]] = []
    format_type = None
    in_vertex = False

    while True:
        line_bytes = f.readline()
        if not line_bytes:
            raise SystemExit("Error: unexpected EOF while reading PLY header.")
        line = line_bytes.decode("ascii", errors="ignore").strip()
        if line == "end_header":
            break
        if not line:
            continue
        tokens = line.split()
        if tokens[0] == "format":
            if len(tokens) < 2:
                raise SystemExit("Error: malformed format line in PLY header.")
            format_type = tokens[1]
        elif tokens[0] == "element":
            in_vertex = tokens[1] == "vertex"
            if in_vertex:
                if len(tokens) < 3:
                    raise SystemExit("Error: malformed element vertex line.")
                vertex_count = int(tokens[2])
        elif tokens[0] == "property" and in_vertex:
            if len(tokens) < 3:
                raise SystemExit("Error: malformed property line for vertex.")
            if tokens[1] == "list":
                raise SystemExit("Error: list properties on vertex are not supported.")
            p_type = tokens[1]
            p_name = tokens[2]
            vertex_props.append((p_name, p_type))

    header_end = f.tell()

    if format_type is None:
        raise SystemExit("Error: PLY format line not found.")
    if vertex_count is None:
        raise SystemExit("Error: PLY element vertex not found.")

    if format_type not in ("ascii", "binary_little_endian"):
        raise SystemExit(f"Error: unsupported PLY format '{format_type}'.")

    return format_type, vertex_count, vertex_props, header_end


def build_output_header(format_type: str, vertex_props, vertex_count: int) -> str:
    lines = []
    lines.append("ply")
    if format_type == "ascii":
        lines.append("format ascii 1.0")
    else:
        lines.append("format binary_little_endian 1.0")
    lines.append("comment generated by crop_ply.py")
    lines.append(f"element vertex {vertex_count}")
    for name, p_type in vertex_props:
        lines.append(f"property {p_type} {name}")
    lines.append("end_header")
    return "\n".join(lines) + "\n"


def crop_ascii_ply(in_path: str, out_path: str, crop_bounds, invert_crop: bool = False):
    xmin, xmax, ymin, ymax, zmin, zmax = crop_bounds
    with open(in_path, "rb") as f:
        format_type, vertex_count, vertex_props, header_end = parse_ply_header(f)
        if format_type != "ascii":
            raise SystemExit("Internal error: crop_ascii_ply called for non-ascii file.")

        # Determine indices of x, y, z within each vertex row
        name_to_index = {name: i for i, (name, _) in enumerate(vertex_props)}
        try:
            ix = name_to_index["x"]
            iy = name_to_index["y"]
            iz = name_to_index["z"]
        except KeyError:
            raise SystemExit("Error: vertex properties must include x, y, z.")

        kept_lines = []
        for _ in range(vertex_count):
            line_bytes = f.readline()
            if not line_bytes:
                raise SystemExit("Error: unexpected EOF while reading ascii vertex data.")
            line_str = line_bytes.decode("ascii", errors="ignore").strip()
            if not line_str:
                continue
            tokens = line_str.split()
            if len(tokens) <= max(ix, iy, iz):
                continue
            try:
                x = float(tokens[ix])
                y = float(tokens[iy])
                z = float(tokens[iz])
            except ValueError:
                continue
            inside_box = (xmin <= x <= xmax) and (ymin <= y <= ymax) and (zmin <= z <= zmax)
            keep = inside_box if not invert_crop else not inside_box
            if keep:
                kept_lines.append(line_str)

    out_header = build_output_header("ascii", vertex_props, len(kept_lines))
    with open(out_path, "w", encoding="ascii") as g:
        g.write(out_header)
        for line in kept_lines:
            g.write(line + "\n")


def crop_binary_ply(in_path: str, out_path: str, crop_bounds, invert_crop: bool = False):
    xmin, xmax, ymin, ymax, zmin, zmax = crop_bounds
    with open(in_path, "rb") as f:
        format_type, vertex_count, vertex_props, header_end = parse_ply_header(f)
        if format_type != "binary_little_endian":
            raise SystemExit("Internal error: crop_binary_ply called for non-binary file.")

        # Map vertex properties to struct format
        fmt_parts = []
        for name, p_type in vertex_props:
            if p_type not in PLY_TYPE_TO_STRUCT:
                raise SystemExit(f"Error: unsupported PLY data type '{p_type}'.")
            fmt_parts.append(PLY_TYPE_TO_STRUCT[p_type])
        struct_fmt = "<" + "".join(fmt_parts)
        rec_size = struct.calcsize(struct_fmt)

        name_to_index = {name: i for i, (name, _) in enumerate(vertex_props)}
        try:
            ix = name_to_index["x"]
            iy = name_to_index["y"]
            iz = name_to_index["z"]
        except KeyError:
            raise SystemExit("Error: vertex properties must include x, y, z.")

        kept_records = []
        for _ in range(vertex_count):
            rec = f.read(rec_size)
            if len(rec) != rec_size:
                raise SystemExit("Error: unexpected EOF while reading binary vertex data.")
            values = struct.unpack(struct_fmt, rec)
            x = float(values[ix])
            y = float(values[iy])
            z = float(values[iz])
            inside_box = (xmin <= x <= xmax) and (ymin <= y <= ymax) and (zmin <= z <= zmax)
            keep = inside_box if not invert_crop else not inside_box
            if keep:
                kept_records.append(rec)

    out_header = build_output_header("binary_little_endian", vertex_props, len(kept_records))
    with open(out_path, "wb") as g:
        g.write(out_header.encode("ascii"))
        for rec in kept_records:
            g.write(rec)


def main(argv=None):
    parser = argparse.ArgumentParser(
        description="Crop a PLY point cloud using a preset.json generated by the web app."
    )
    parser.add_argument("--ply", required=True, help="Input PLY file path.")
    parser.add_argument("--preset", required=True, help="preset.json file path.")
    parser.add_argument(
        "--out",
        help="Output PLY path. If omitted, 'cropped_<input_basename>.ply' is used.",
    )
    args = parser.parse_args(argv)

    ply_path = args.ply
    preset_path = args.preset
    if not os.path.isfile(ply_path):
        raise SystemExit(f"Error: PLY file not found: {ply_path}")
    if not os.path.isfile(preset_path):
        raise SystemExit(f"Error: preset file not found: {preset_path}")

    crop_bounds, invert_crop, _custom_planes = read_preset(preset_path)

    with open(ply_path, "rb") as f:
        format_type, vertex_count, vertex_props, header_end = parse_ply_header(f)

    if args.out:
        out_path = args.out
    else:
        base = os.path.basename(ply_path)
        root, ext = os.path.splitext(base)
        if not ext:
            ext = ".ply"
        out_path = os.path.join(os.path.dirname(ply_path), f"cropped_{root}{ext}")

    if format_type == "ascii":
        crop_ascii_ply(ply_path, out_path, crop_bounds, invert_crop=invert_crop)
    elif format_type == "binary_little_endian":
        crop_binary_ply(ply_path, out_path, crop_bounds, invert_crop=invert_crop)
    else:
        raise SystemExit(f"Error: unsupported PLY format '{format_type}'.")

    print(f"Written cropped PLY: {out_path}")


if __name__ == "__main__":
    main()
