<!doctype html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Point Cloud Cropper</title>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
        background: #0b0c10;
        color: #e6e6e6;
      }
      #layout {
        display: flex;
        height: 100%;
        width: 100%;
      }
      #viewport-container {
        position: relative;
        flex: 1 1 auto;
        background: #000;
        overflow: hidden;
      }
      #viewport {
        width: 100%;
        height: 100%;
      }
      #drop-hint {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        font-size: 15px;
        color: #d0d7de;
        pointer-events: none;
        opacity: 0.8;
      }
      #drop-overlay {
        position: absolute;
        inset: 0;
        background: rgba(67, 160, 255, 0.18);
        border: 2px dashed rgba(138, 180, 255, 0.9);
        border-radius: 8px;
        display: none;
        align-items: center;
        justify-content: center;
        color: #e6f1ff;
        font-size: 16px;
        font-weight: 500;
        pointer-events: none;
        box-shadow: 0 0 0 1px rgba(17, 25, 40, 0.6);
      }
      #sidebar {
        width: 320px;
        max-width: 40vw;
        background: rgba(17, 25, 40, 0.96);
        border-left: 1px solid rgba(148, 163, 184, 0.32);
        box-shadow: -8px 0 24px rgba(0, 0, 0, 0.45);
        padding: 14px 16px 18px;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      #sidebar h1 {
        font-size: 16px;
        margin: 0 0 4px;
        font-weight: 600;
        letter-spacing: .04em;
        text-transform: uppercase;
        color: #e5e9f0;
      }
      #sidebar .subtitle {
        font-size: 11px;
        color: #9ca3af;
        margin-bottom: 6px;
      }
      .section {
        border-radius: 8px;
        background: radial-gradient(circle at top left, rgba(148, 163, 255, 0.12), rgba(15, 23, 42, 0.95));
        border: 1px solid rgba(148, 163, 184, 0.32);
        padding: 8px 9px 9px;
        margin-bottom: 6px;
      }
      .section-header {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        margin-bottom: 4px;
      }
      .section-title {
        font-size: 12px;
        font-weight: 600;
        letter-spacing: .03em;
        text-transform: uppercase;
        color: #e5e7eb;
      }
      .section-note {
        font-size: 10px;
        color: #9ca3af;
      }
      .field-row {
        display: grid;
        grid-template-columns: 1.2fr 2.2fr 0.9fr;
        gap: 6px;
        align-items: center;
        margin: 4px 0;
      }
      .field-row-compact {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 6px;
        align-items: center;
        margin: 3px 0;
      }
      label {
        font-size: 11px;
        color: #d1d5db;
      }
      input[type="range"] {
        width: 100%;
      }
      input[type="number"] {
        width: 100%;
        box-sizing: border-box;
        padding: 2px 4px;
        border-radius: 4px;
        border: 1px solid rgba(148, 163, 184, 0.7);
        background: rgba(15, 23, 42, 0.9);
        color: #e5e7eb;
        font-size: 11px;
      }
      input[type="number"]:focus {
        outline: none;
        border-color: #60a5fa;
        box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.5);
      }
      .value-label {
        text-align: right;
        font-variant-numeric: tabular-nums;
        font-size: 11px;
        color: #a5b4fc;
      }
      .stat-line {
        display: flex;
        justify-content: space-between;
        font-size: 11px;
        margin: 2px 0;
        color: #d1d5db;
      }
      .stat-line span.value {
        color: #bfdbfe;
        font-variant-numeric: tabular-nums;
      }
      button {
        font-size: 12px;
        border-radius: 999px;
        padding: 6px 10px;
        border: none;
        cursor: pointer;
        background: linear-gradient(135deg, #2563eb, #4f46e5);
        color: #e5e7eb;
        font-weight: 500;
        box-shadow: 0 8px 18px rgba(37, 99, 235, 0.45);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
      }
      button.secondary {
        background: rgba(15, 23, 42, 0.95);
        border: 1px solid rgba(148, 163, 184, 0.7);
        box-shadow: none;
      }
      button:disabled {
        opacity: 0.5;
        cursor: default;
        box-shadow: none;
      }
      #footer-note {
        margin-top: auto;
        font-size: 10px;
        color: #9ca3af;
        line-height: 1.4;
      }
      #footer-note code {
        font-size: 10px;
        background: rgba(15, 23, 42, 0.9);
        padding: 1px 4px;
        border-radius: 4px;
        border: 1px solid rgba(75, 85, 99, 0.8);
      }
      #info-banner {
        position: absolute;
        left: 10px;
        top: 10px;
        background: rgba(0, 0, 0, 0.5);
        color: #e5e7eb;
        font-size: 11px;
        padding: 6px 8px;
        border-radius: 6px;
        pointer-events: none;
        z-index: 5;
      }
      #info-banner div {
        margin: 1px 0;
      }
      @media (max-width: 880px) {
        #layout {
          flex-direction: column;
        }
        #sidebar {
          width: 100%;
          max-width: none;
          border-left: none;
          border-top: 1px solid rgba(148, 163, 184, 0.32);
          box-shadow: 0 -8px 24px rgba(0, 0, 0, 0.75);
        }
      }
    </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
        }
      }
    </script>
  </head>
  <body>
    <div id="layout">
      <div id="viewport-container">
        <div id="viewport"></div>
        <div id="drop-hint">
          Drag &amp; Drop a point cloud PLY file here.
        </div>
        <div id="drop-overlay">Drop here to load PLY</div>
        <div id="info-banner">
          <div>Left drag: orbit camera</div>
          <div>Mouse wheel: zoom · Right drag: pan</div>
          <div>Click &amp; drag plane: move crop box</div>
        </div>
      </div>
      <div id="sidebar">
        <h1>Point Cloud Cropper</h1>
        <div class="subtitle">PLY cropping tool powered by three.js</div>

        <div class="section">
          <div class="section-header">
            <div class="section-title">File</div>
          </div>
          <div class="stat-line">
            <span>Name</span>
            <span class="value" id="fileName">-</span>
          </div>
          <div class="stat-line">
            <span>Points</span>
            <span class="value" id="pointCount">-</span>
          </div>
        </div>

        <div class="section">
          <div class="section-header">
            <div class="section-title">Point Size</div>
            <div class="section-note">URL param: <code>ps</code></div>
          </div>
          <div class="field-row">
            <label for="pointSizeRange">Size</label>
            <input id="pointSizeRange" type="range" min="0.0001" max="10" step="0.0001" />
            <div class="value-label" id="pointSizeLabel">-</div>
          </div>
        </div>

        <div class="section">
          <div class="section-header">
            <div class="section-title">Crop Box</div>
            <div class="section-note">URL params: <code>xmin..zmax</code>, <code>inv</code>, <code>cb</code></div>
          </div>
          <div class="field-row-compact">
            <label for="xminInput">X Min</label>
            <input id="xminInput" type="number" step="0.001" />
          </div>
          <div class="field-row-compact">
            <label for="xmaxInput">X Max</label>
            <input id="xmaxInput" type="number" step="0.001" />
          </div>
          <div class="field-row-compact">
            <label for="yminInput">Y Min</label>
            <input id="yminInput" type="number" step="0.001" />
          </div>
          <div class="field-row-compact">
            <label for="ymaxInput">Y Max</label>
            <input id="ymaxInput" type="number" step="0.001" />
          </div>
          <div class="field-row-compact">
            <label for="zminInput">Z Min</label>
            <input id="zminInput" type="number" step="0.001" />
          </div>
          <div class="field-row-compact">
            <label for="zmaxInput">Z Max</label>
            <input id="zmaxInput" type="number" step="0.001" />
          </div>
          <div class="field-row-compact" style="margin-top: 2px;">
            <label for="invertCrop">Invert Crop</label>
            <input id="invertCrop" type="checkbox" />
          </div>
          <div class="field-row-compact">
            <label for="showCropBox">Show Crop Box</label>
            <input id="showCropBox" type="checkbox" />
          </div>
          <div style="display:flex; gap:6px; margin-top:4px;">
            <button id="resetCropButton" class="secondary" disabled>Reset to full extent</button>
          </div>
        </div>

        <div class="section">
          <div class="section-header">
            <div class="section-title">Custom Planes</div>
            <div class="section-note">URL params: <code>cpYaw</code>, <code>cpPitch</code>, <code>cpPx..cpPz</code>, <code>cps</code></div>
          </div>
          <div class="field-row-compact" style="margin-bottom:4px;">
            <label for="showCustomPlanes">Show All Planes</label>
            <input id="showCustomPlanes" type="checkbox" />
          </div>
          <div style="display:flex; gap:6px; margin-bottom:4px;">
            <button id="addPlaneButton" class="secondary" style="flex:1;">Add Plane</button>
            <button id="clearPlanesButton" class="secondary" style="flex:1;">Clear All</button>
          </div>
          <div id="customPlanesList" style="max-height:140px; overflow-y:auto;"></div>
        </div>

        <div class="section">
          <div class="section-header">
            <div class="section-title">Magic Volume</div>
            <div class="section-note">Shift+click: pick seed · URL: <code>ml</code>, <code>ms</code></div>
          </div>
          <div class="field-row">
            <label for="magicLength">Magic Point Length</label>
            <input id="magicLength" type="range" min="0.000001" max="1.0" step="0.000001" />
            <div class="value-label" id="magicLengthVal">-</div>
          </div>
          <div class="stat-line">
            <span>Magic Group Points</span>
            <span class="value" id="magicCount">-</span>
          </div>
        </div>

        <div class="section">
          <div class="section-header">
            <div class="section-title">Export</div>
          </div>
          <div style="display:flex; gap:6px; flex-wrap:wrap;">
            <button id="downloadButton" disabled>Download: cropped PLY</button>
            <button id="presetButton" class="secondary" disabled>Download preset.json</button>
          </div>
        </div>

        <div id="footer-note">
          - The six crop-box planes are initially set to the minimal box that contains the entire cloud.<br />
          - Drag planes or edit values on the right panel and the current <code>ps</code>, <code>xmin..zmax</code>, Magic Volume, and custom planes are encoded into the URL query.<br />
          - Share that URL to reproduce the same view and parameters<br />
          &nbsp;&nbsp;(the receiver still needs to drop the same PLY file).
        </div>
      </div>
    </div>

    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
      import { TransformControls } from 'three/addons/controls/TransformControls.js';
      import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';

      const viewport = document.getElementById('viewport');
      const dropHint = document.getElementById('drop-hint');
      const dropOverlay = document.getElementById('drop-overlay');
      const fileNameEl = document.getElementById('fileName');
      const pointCountEl = document.getElementById('pointCount');
      const pointSizeRange = document.getElementById('pointSizeRange');
      const pointSizeLabel = document.getElementById('pointSizeLabel');
      const resetCropButton = document.getElementById('resetCropButton');
      const downloadButton = document.getElementById('downloadButton');
      const presetButton = document.getElementById('presetButton');

      const xminInput = document.getElementById('xminInput');
      const xmaxInput = document.getElementById('xmaxInput');
      const yminInput = document.getElementById('yminInput');
      const ymaxInput = document.getElementById('ymaxInput');
      const zminInput = document.getElementById('zminInput');
      const zmaxInput = document.getElementById('zmaxInput');
      const invertCropInput = document.getElementById('invertCrop');
      const showCropBoxInput = document.getElementById('showCropBox');
      const showCustomPlanesInput = document.getElementById('showCustomPlanes');
      const addPlaneButton = document.getElementById('addPlaneButton');
      const clearPlanesButton = document.getElementById('clearPlanesButton');
      const customPlanesList = document.getElementById('customPlanesList');
      const magicLengthRange = document.getElementById('magicLength');
      const magicLengthVal = document.getElementById('magicLengthVal');
      const magicCountEl = document.getElementById('magicCount');

      const DEFAULT_POINT_SIZE = 1.0e-4;

      function readURLConfig() {
        const q = new URLSearchParams(window.location.search);
        const num = (k) => {
          if (!q.has(k)) return undefined;
          const v = parseFloat(q.get(k));
          return Number.isFinite(v) ? v : undefined;
        };
        const boolParam = (k) => {
          if (!q.has(k)) return undefined;
          const v = q.get(k);
          return /^(1|true|on|yes)$/i.test(v);
        };
        const intParam = (k) => {
          if (!q.has(k)) return undefined;
          const v = parseInt(q.get(k), 10);
          return Number.isFinite(v) ? v : undefined;
        };
        const cfg = {
          pointSize: num('ps'),
          crop: null,
          invertCrop: undefined,
          showCropBox: undefined,
          showCustomPlanes: undefined,
          magicLength: num('ml'),
          magicSeedIndex: intParam('ms'),
          customPlanes: []
        };
        const keys = ['xmin', 'xmax', 'ymin', 'ymax', 'zmin', 'zmax'];
        const crop = {};
        let allPresent = true;
        for (const k of keys) {
          const v = num(k);
          if (v == null) {
            allPresent = false;
            break;
          }
          crop[k] = v;
        }
        if (allPresent) cfg.crop = crop;

        cfg.invertCrop = boolParam('inv');
        cfg.showCropBox = boolParam('cb');
        cfg.showCustomPlanes = boolParam('cps');

        const yawStr = q.get('cpYaw');
        const pitchStr = q.get('cpPitch');
        const pxStr = q.get('cpPx');
        const pyStr = q.get('cpPy');
        const pzStr = q.get('cpPz');
        const visStr = q.get('cpVis');
        if (yawStr) {
          const yawArr = yawStr.split(',').map((s) => parseFloat(s)).filter((v) => Number.isFinite(v));
          const pitchArr = pitchStr
            ? pitchStr.split(',').map((s) => parseFloat(s))
            : [];
          const pxArr = pxStr ? pxStr.split(',').map((s) => parseFloat(s)) : [];
          const pyArr = pyStr ? pyStr.split(',').map((s) => parseFloat(s)) : [];
          const pzArr = pzStr ? pzStr.split(',').map((s) => parseFloat(s)) : [];
          const visArr = visStr ? visStr.split(',') : [];
          cfg.customPlanes = yawArr.map((yaw, i) => {
            const pitch = Number.isFinite(pitchArr[i]) ? pitchArr[i] : 0;
            const px = Number.isFinite(pxArr[i]) ? pxArr[i] : undefined;
            const py = Number.isFinite(pyArr[i]) ? pyArr[i] : undefined;
            const pz = Number.isFinite(pzArr[i]) ? pzArr[i] : undefined;
            const visible = visArr[i] === '0' ? false : true;
            return { yaw, pitch, px, py, pz, visible };
          });
        }
        return cfg;
      }

      const initialURL = readURLConfig();
      const params = {
        pointSize: initialURL.pointSize ?? DEFAULT_POINT_SIZE,
        invertCrop: initialURL.invertCrop ?? false,
        showCropBox: initialURL.showCropBox ?? true,
        showCustomPlanes: initialURL.showCustomPlanes ?? true,
        magicLength: initialURL.magicLength ?? 0.00076,
        magicSeedIndex: initialURL.magicSeedIndex ?? null,
        customPlanes: initialURL.customPlanes ?? []
      };

      const CUSTOM_PLANE_COLORS = [
        0xff4b5c,
        0x22c55e,
        0x3b82f6,
        0xf97316,
        0xa855f7,
        0x14b8a6
      ];

      let magicIndex = null; // spatial index for Magic Volume
      let magicJob = null; // incremental BFS job for Magic Volume
      let magicMask = null; // Uint8Array marking Magic group points

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      const camera = new THREE.PerspectiveCamera(60, 1, 0.01, 1000);
      camera.position.set(0, 0, 5);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.localClippingEnabled = true;
      viewport.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.target.set(0, 0, 0);

      const ambient = new THREE.AmbientLight(0xffffff, 0.35);
      scene.add(ambient);
      const dir = new THREE.DirectionalLight(0xffffff, 0.9);
      dir.position.set(3, 5, 4);
      scene.add(dir);

      const grid = new THREE.GridHelper(10, 20, 0x4b5563, 0x111827);
      grid.position.y = -0.0001;
      scene.add(grid);

      const plyLoader = new PLYLoader();
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();

      let pointCloud = null;
      let pointGeometry = null;
      let pointMaterial = null;
      let sourceFileName = null;
      let sourceBBox = null;
      let hasPointColors = false;

      const crop = {
        xmin: null,
        xmax: null,
        ymin: null,
        ymax: null,
        zmin: null,
        zmax: null
      };
      const cropPlanes = {};
      let transformControls = null;
      let hasAppliedInitialCropFromURL = false;
      const customPlaneMeshes = [];
      let smallRegionBox = null;
      let smallRegionHelper = null;
      let regionMesh = null;
      let regionMaterial = null;
      let lastRegionInfo = null;
      let currentSelectionType = null; // 'crop' | 'custom' | null

      function resizeRenderer() {
        const rect = viewport.getBoundingClientRect();
        const width = rect.width || 1;
        const height = rect.height || 1;
        renderer.setSize(width, height, false);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
      }

      window.addEventListener('resize', resizeRenderer);
      resizeRenderer();

      function updateCropBoxVisibility() {
        const visible = !!params.showCropBox;
        for (const key in cropPlanes) {
          const mesh = cropPlanes[key];
          if (mesh) mesh.visible = visible;
        }
      }

      function clearRegionHighlight() {
        lastRegionInfo = null;
        if (smallRegionHelper) smallRegionHelper.visible = false;
        if (regionMesh) regionMesh.visible = false;
      }

      function clearMagicState() {
        magicIndex = null;
        magicCountEl.textContent = '-';
        magicJob = null;
        magicMask = null;
      }

      function ensureRegionHighlightObjects() {
        if (!smallRegionBox) {
          smallRegionBox = new THREE.Box3();
        }
        if (!smallRegionHelper) {
          smallRegionHelper = new THREE.Box3Helper(smallRegionBox, 0xffd166);
          smallRegionHelper.visible = false;
          scene.add(smallRegionHelper);
        }
        if (!regionMesh) {
          const geo = new THREE.BoxGeometry(1, 1, 1);
          regionMaterial = new THREE.MeshBasicMaterial({
            color: 0xffd166,
            transparent: true,
            opacity: 0.22,
            side: THREE.DoubleSide,
            depthWrite: false,
            clippingPlanes: []
          });
          regionMesh = new THREE.Mesh(geo, regionMaterial);
          regionMesh.renderOrder = 3;
          regionMesh.visible = false;
          scene.add(regionMesh);
        }
      }

      function updateURLFromState() {
        const q = new URLSearchParams(window.location.search);

        if (params.pointSize != null) {
          q.set('ps', params.pointSize.toString());
        }

        if (params.invertCrop) {
          q.set('inv', '1');
        } else {
          q.delete('inv');
        }

        q.set('cb', params.showCropBox ? '1' : '0');
        q.set('cps', params.showCustomPlanes ? '1' : '0');

        if (params.magicLength != null) {
          q.set('ml', params.magicLength.toString());
        } else {
          q.delete('ml');
        }

        if (params.magicSeedIndex != null && Number.isFinite(params.magicSeedIndex)) {
          q.set('ms', String(params.magicSeedIndex));
        } else {
          q.delete('ms');
        }

        if (crop.xmin != null && crop.xmax != null &&
            crop.ymin != null && crop.ymax != null &&
            crop.zmin != null && crop.zmax != null) {
          q.set('xmin', crop.xmin.toFixed(4));
          q.set('xmax', crop.xmax.toFixed(4));
          q.set('ymin', crop.ymin.toFixed(4));
          q.set('ymax', crop.ymax.toFixed(4));
          q.set('zmin', crop.zmin.toFixed(4));
          q.set('zmax', crop.zmax.toFixed(4));
        }

        if (params.customPlanes && params.customPlanes.length) {
          const yawStr = params.customPlanes.map((p) => (p.yaw || 0).toFixed(2)).join(',');
          const pitchStr = params.customPlanes.map((p) => (p.pitch || 0).toFixed(2)).join(',');
          const pxStr = params.customPlanes.map((p) => (p.px ?? (crop.xmin + crop.xmax) / 2).toFixed(4)).join(',');
          const pyStr = params.customPlanes.map((p) => (p.py ?? (crop.ymin + crop.ymax) / 2).toFixed(4)).join(',');
          const pzStr = params.customPlanes.map((p) => (p.pz ?? (crop.zmin + crop.zmax) / 2).toFixed(4)).join(',');
          const visStr = params.customPlanes.map((p) => (p.visible === false ? '0' : '1')).join(',');
          q.set('cpYaw', yawStr);
          q.set('cpPitch', pitchStr);
          q.set('cpPx', pxStr);
          q.set('cpPy', pyStr);
          q.set('cpPz', pzStr);
          q.set('cpVis', visStr);
        } else {
          q.delete('cpYaw');
          q.delete('cpPitch');
          q.delete('cpPx');
          q.delete('cpPy');
          q.delete('cpPz');
          q.delete('cpVis');
        }

        const query = q.toString();
        const url = window.location.pathname + (query ? '?' + query : '');
        window.history.replaceState(null, '', url);
      }

      function clampCropToBBox() {
        if (!sourceBBox) return;
        const eps = 1e-5;
        const min = sourceBBox.min;
        const max = sourceBBox.max;

        crop.xmin = Math.max(min.x, crop.xmin);
        crop.xmax = Math.min(max.x, crop.xmax);
        crop.ymin = Math.max(min.y, crop.ymin);
        crop.ymax = Math.min(max.y, crop.ymax);
        crop.zmin = Math.max(min.z, crop.zmin);
        crop.zmax = Math.min(max.z, crop.zmax);

        if (crop.xmax <= crop.xmin) crop.xmax = crop.xmin + eps;
        if (crop.ymax <= crop.ymin) crop.ymax = crop.ymin + eps;
        if (crop.zmax <= crop.zmin) crop.zmax = crop.zmin + eps;
      }

      function applyInitialCropFromURLIfAny() {
        if (hasAppliedInitialCropFromURL) return;
        if (!initialURL.crop) return;
        if (!sourceBBox) return;

        crop.xmin = initialURL.crop.xmin;
        crop.xmax = initialURL.crop.xmax;
        crop.ymin = initialURL.crop.ymin;
        crop.ymax = initialURL.crop.ymax;
        crop.zmin = initialURL.crop.zmin;
        crop.zmax = initialURL.crop.zmax;
        clampCropToBBox();
        hasAppliedInitialCropFromURL = true;
      }

      function initCropFromBBox() {
        if (!sourceBBox) return;

        if (!hasAppliedInitialCropFromURL && initialURL.crop) {
          applyInitialCropFromURLIfAny();
        } else {
          crop.xmin = sourceBBox.min.x;
          crop.xmax = sourceBBox.max.x;
          crop.ymin = sourceBBox.min.y;
          crop.ymax = sourceBBox.max.y;
          crop.zmin = sourceBBox.min.z;
          crop.zmax = sourceBBox.max.z;
        }

        clampCropToBBox();
        createCropPlanesIfNeeded();
        updateCropPlanesFromState();
        updateCropInputsFromState();
        updateCropBoxVisibility();
        updateCustomPlaneMeshesFromParams();
        recomputeRegionInfoAndHighlight();
        updateURLFromState();
      }

      function createCropPlanesIfNeeded() {
        if (transformControls) return;

        const planeGeo = new THREE.PlaneGeometry(1, 1);

        function makeMaterial(color) {
          return new THREE.MeshBasicMaterial({
            color,
            transparent: true,
            opacity: 0.18,
            side: THREE.DoubleSide,
            depthWrite: false
          });
        }

        cropPlanes.xmin = new THREE.Mesh(planeGeo, makeMaterial(0xff5c5c));
        cropPlanes.xmax = new THREE.Mesh(planeGeo, makeMaterial(0xff5c5c));
        cropPlanes.ymin = new THREE.Mesh(planeGeo, makeMaterial(0x22c55e));
        cropPlanes.ymax = new THREE.Mesh(planeGeo, makeMaterial(0x22c55e));
        cropPlanes.zmin = new THREE.Mesh(planeGeo, makeMaterial(0x38bdf8));
        cropPlanes.zmax = new THREE.Mesh(planeGeo, makeMaterial(0x38bdf8));

        cropPlanes.xmin.userData.cropKey = 'xmin';
        cropPlanes.xmax.userData.cropKey = 'xmax';
        cropPlanes.ymin.userData.cropKey = 'ymin';
        cropPlanes.ymax.userData.cropKey = 'ymax';
        cropPlanes.zmin.userData.cropKey = 'zmin';
        cropPlanes.zmax.userData.cropKey = 'zmax';

        cropPlanes.xmin.rotation.y = Math.PI / 2;
        cropPlanes.xmax.rotation.y = Math.PI / 2;
        cropPlanes.ymin.rotation.x = -Math.PI / 2;
        cropPlanes.ymax.rotation.x = -Math.PI / 2;

        for (const key in cropPlanes) {
          const mesh = cropPlanes[key];
          mesh.name = 'CropPlane_' + key;
          mesh.renderOrder = 1;
          scene.add(mesh);
        }

        transformControls = new TransformControls(camera, renderer.domElement);
        transformControls.setMode('translate');
        transformControls.size = 0.8;
        transformControls.addEventListener('dragging-changed', (event) => {
          controls.enabled = !event.value;
        });
        transformControls.addEventListener('objectChange', () => {
          const obj = transformControls.object;
          if (!obj || !obj.userData) return;

          if (obj.userData.cropKey) {
            const key = obj.userData.cropKey;
            const p = obj.position;
            const eps = 1e-5;
            if (key === 'xmin') {
              crop.xmin = p.x;
              if (crop.xmin > crop.xmax - eps) crop.xmin = crop.xmax - eps;
            } else if (key === 'xmax') {
              crop.xmax = p.x;
              if (crop.xmax < crop.xmin + eps) crop.xmax = crop.xmin + eps;
            } else if (key === 'ymin') {
              crop.ymin = p.y;
              if (crop.ymin > crop.ymax - eps) crop.ymin = crop.ymax - eps;
            } else if (key === 'ymax') {
              crop.ymax = p.y;
              if (crop.ymax < crop.ymin + eps) crop.ymax = crop.ymin + eps;
            } else if (key === 'zmin') {
              crop.zmin = p.z;
              if (crop.zmin > crop.zmax - eps) crop.zmin = crop.zmax - eps;
            } else if (key === 'zmax') {
              crop.zmax = p.z;
              if (crop.zmax < crop.zmin + eps) crop.zmax = crop.zmin + eps;
            }
            clampCropToBBox();
            updateCropPlanesFromState();
            updateCropInputsFromState();
            updateCustomPlaneMeshesFromParams();
            recomputeRegionInfoAndHighlight();
            updateURLFromState();
          } else if (obj.userData.customPlaneIndex != null && params.customPlanes) {
            const idx = obj.userData.customPlaneIndex;
            const plane = params.customPlanes[idx];
            if (!plane) return;

            if (crop.xmin != null) {
              const p = obj.position;
              const px = Math.min(Math.max(p.x, crop.xmin), crop.xmax);
              const py = Math.min(Math.max(p.y, crop.ymin), crop.ymax);
              const pz = Math.min(Math.max(p.z, crop.zmin), crop.zmax);
              plane.px = px;
              plane.py = py;
              plane.pz = pz;
            }

            const normal = new THREE.Vector3(0, 0, 1).applyQuaternion(obj.quaternion).normalize();
            const pitchRad = Math.asin(THREE.MathUtils.clamp(normal.y, -1, 1));
            const yawRad = Math.atan2(normal.x, normal.z);
            plane.yaw = THREE.MathUtils.radToDeg(yawRad);
            plane.pitch = THREE.MathUtils.radToDeg(pitchRad);

            updateCustomPlaneMeshesFromParams();
            recomputeRegionInfoAndHighlight();
            updateURLFromState();
          }
        });
        scene.add(transformControls);

        renderer.domElement.addEventListener('pointerdown', onPointerDownForCropPlanes);

        updateCropBoxVisibility();
      }

      function updateCropPlanesFromState() {
        if (!sourceBBox) return;

        const cx = (crop.xmin + crop.xmax) / 2;
        const cy = (crop.ymin + crop.ymax) / 2;
        const cz = (crop.zmin + crop.zmax) / 2;
        const sx = Math.max(crop.xmax - crop.xmin, 1e-4);
        const sy = Math.max(crop.ymax - crop.ymin, 1e-4);
        const sz = Math.max(crop.zmax - crop.zmin, 1e-4);

        const p = cropPlanes;

        if (!p.xmin) return;

        p.xmin.position.set(crop.xmin, cy, cz);
        p.xmax.position.set(crop.xmax, cy, cz);
        p.ymin.position.set(cx, crop.ymin, cz);
        p.ymax.position.set(cx, crop.ymax, cz);
        p.zmin.position.set(cx, cy, crop.zmin);
        p.zmax.position.set(cx, cy, crop.zmax);

        p.xmin.scale.set(sz, sy, 1);
        p.xmax.scale.set(sz, sy, 1);
        p.ymin.scale.set(sx, sz, 1);
        p.ymax.scale.set(sx, sz, 1);
        p.zmin.scale.set(sx, sy, 1);
        p.zmax.scale.set(sx, sy, 1);
      }

      function onPointerDownForCropPlanes(event) {
        if (!pointCloud) return;
        if (!transformControls) return;
        if (event.shiftKey) {
          const rect0 = renderer.domElement.getBoundingClientRect();
          const x0 = ((event.clientX - rect0.left) / rect0.width) * 2 - 1;
          const y0 = -((event.clientY - rect0.top) / rect0.height) * 2 + 1;
          mouse.set(x0, y0);
          raycaster.setFromCamera(mouse, camera);
          if (pointCloud) {
            raycaster.params.Points = raycaster.params.Points || {};
            raycaster.params.Points.threshold = params.magicLength || 0.01;
            const hits = raycaster.intersectObject(pointCloud, false);
            if (hits.length > 0) {
              const seedIndex = hits[0].index;
              runMagicVolumeFromSeed(seedIndex);
            }
          }
          return;
        }
        const rect = renderer.domElement.getBoundingClientRect();
        const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        mouse.set(x, y);
        raycaster.setFromCamera(mouse, camera);

        const targets = [];
        if (params.showCropBox) {
          targets.push(...Object.values(cropPlanes));
        }
        if (params.showCustomPlanes) {
          targets.push(...customPlaneMeshes);
        }

        const intersects = raycaster.intersectObjects(targets);
        if (!intersects.length) return;

        const picked = intersects[0].object;
        transformControls.attach(picked);
        transformControls.showX = transformControls.showY = transformControls.showZ = false;

        if (picked.userData && picked.userData.cropKey) {
          const key = picked.userData.cropKey;
          currentSelectionType = 'crop';
          transformControls.setMode('translate');
          if (key === 'xmin' || key === 'xmax') {
            transformControls.axis = 'X';
            transformControls.showX = true;
          } else if (key === 'ymin' || key === 'ymax') {
            transformControls.axis = 'Y';
            transformControls.showY = true;
          } else if (key === 'zmin' || key === 'zmax') {
            transformControls.axis = 'Z';
            transformControls.showZ = true;
          }
        } else if (picked.userData && picked.userData.customPlaneIndex != null) {
          currentSelectionType = 'custom';
          transformControls.setMode('translate');
          transformControls.showX = transformControls.showY = transformControls.showZ = true;
        } else {
          currentSelectionType = null;
        }
      }

      function updateCropInputsFromState() {
        if (crop.xmin == null) return;
        xminInput.value = crop.xmin.toFixed(4);
        xmaxInput.value = crop.xmax.toFixed(4);
        yminInput.value = crop.ymin.toFixed(4);
        ymaxInput.value = crop.ymax.toFixed(4);
        zminInput.value = crop.zmin.toFixed(4);
        zmaxInput.value = crop.zmax.toFixed(4);
      }

      function updateStateFromCropInputs() {
        if (!sourceBBox) return;
        const v = (input, fallback) => {
          const t = parseFloat(input.value);
          return Number.isFinite(t) ? t : fallback;
        };
        crop.xmin = v(xminInput, crop.xmin);
        crop.xmax = v(xmaxInput, crop.xmax);
        crop.ymin = v(yminInput, crop.ymin);
        crop.ymax = v(ymaxInput, crop.ymax);
        crop.zmin = v(zminInput, crop.zmin);
        crop.zmax = v(zmaxInput, crop.zmax);
        clampCropToBBox();
        updateCropPlanesFromState();
        updateCropInputsFromState();
        updateCustomPlaneMeshesFromParams();
        recomputeRegionInfoAndHighlight();
        updateURLFromState();
      }

      xminInput.addEventListener('change', updateStateFromCropInputs);
      xmaxInput.addEventListener('change', updateStateFromCropInputs);
      yminInput.addEventListener('change', updateStateFromCropInputs);
      ymaxInput.addEventListener('change', updateStateFromCropInputs);
      zminInput.addEventListener('change', updateStateFromCropInputs);
      zmaxInput.addEventListener('change', updateStateFromCropInputs);

      invertCropInput.checked = !!params.invertCrop;
      invertCropInput.addEventListener('change', () => {
        params.invertCrop = !!invertCropInput.checked;
        updateURLFromState();
      });

      showCropBoxInput.checked = !!params.showCropBox;
      showCropBoxInput.addEventListener('change', () => {
        params.showCropBox = !!showCropBoxInput.checked;
        updateCropBoxVisibility();
        if (!params.showCropBox && transformControls && transformControls.object && transformControls.object.userData && transformControls.object.userData.cropKey) {
          transformControls.detach();
          currentSelectionType = null;
        }
        updateURLFromState();
      });

      showCustomPlanesInput.checked = !!params.showCustomPlanes;
      showCustomPlanesInput.addEventListener('change', () => {
        params.showCustomPlanes = !!showCustomPlanesInput.checked;
        updateCustomPlaneMeshesFromParams();
        if (!params.showCustomPlanes && transformControls && transformControls.object && transformControls.object.userData && transformControls.object.userData.customPlaneIndex != null) {
          transformControls.detach();
          currentSelectionType = null;
        }
        updateURLFromState();
      });

      magicLengthRange.value = params.magicLength.toString();
      magicLengthVal.textContent = params.magicLength.toExponential(2);
      magicLengthRange.addEventListener('input', () => {
        let v = parseFloat(magicLengthRange.value);
        if (!Number.isFinite(v) || v <= 0) v = 0.00001;
        params.magicLength = v;
        magicLengthVal.textContent = params.magicLength.toExponential(2);
        // spatial index depends on radius
        magicIndex = null;
        updateURLFromState();
      });

      function formatPointSizeLabel(v) {
        if (v >= 1) return v.toFixed(1) + ' px';
        if (v >= 0.01) return v.toFixed(4) + ' px';
        return v.toExponential(2) + ' px';
      }

      pointSizeRange.value = params.pointSize.toString();
      pointSizeLabel.textContent = formatPointSizeLabel(params.pointSize);
      pointSizeRange.addEventListener('input', () => {
        params.pointSize = parseFloat(pointSizeRange.value) || DEFAULT_POINT_SIZE;
        pointSizeLabel.textContent = formatPointSizeLabel(params.pointSize);
        if (pointMaterial) {
          pointMaterial.size = params.pointSize;
          pointMaterial.needsUpdate = true;
        }
        updateURLFromState();
      });

      function rebuildCustomPlanesListUI() {
        customPlanesList.innerHTML = '';
        if (!params.customPlanes) params.customPlanes = [];
        params.customPlanes.forEach((plane, index) => {
          const row = document.createElement('div');
          row.className = 'field-row-compact';
          row.style.alignItems = 'center';
          row.style.marginBottom = '4px';

          const label = document.createElement('div');
          label.style.display = 'flex';
          label.style.alignItems = 'center';
          label.style.gap = '4px';
          label.style.fontSize = '11px';
          const nameSpan = document.createElement('span');
          nameSpan.textContent = `Plane ${index + 1}`;
          const visLabel = document.createElement('label');
          visLabel.style.display = 'flex';
          visLabel.style.alignItems = 'center';
          visLabel.style.gap = '2px';
          visLabel.style.fontSize = '10px';
          const visCheckbox = document.createElement('input');
          visCheckbox.type = 'checkbox';
          visCheckbox.checked = plane.visible !== false;
          const visText = document.createElement('span');
          visText.textContent = 'Show';
          visLabel.appendChild(visCheckbox);
          visLabel.appendChild(visText);
          label.appendChild(nameSpan);
          label.appendChild(visLabel);

          const controls = document.createElement('div');
          controls.style.display = 'flex';
          controls.style.gap = '4px';

          const yawInput = document.createElement('input');
          yawInput.type = 'number';
          yawInput.step = '1';
          yawInput.style.width = '40px';
          yawInput.value = (plane.yaw || 0).toFixed(0);
          yawInput.title = 'Yaw (deg)';

          const pitchInput = document.createElement('input');
          pitchInput.type = 'number';
          pitchInput.step = '1';
          pitchInput.style.width = '40px';
          pitchInput.value = (plane.pitch || 0).toFixed(0);
          pitchInput.title = 'Pitch (deg)';

          const delButton = document.createElement('button');
          delButton.textContent = 'X';
          delButton.className = 'secondary';
          delButton.style.padding = '2px 6px';
          delButton.style.fontSize = '10px';

          visCheckbox.addEventListener('change', () => {
            plane.visible = !!visCheckbox.checked;
            updateCustomPlaneMeshesFromParams();
            recomputeRegionInfoAndHighlight();
            updateURLFromState();
          });

          yawInput.addEventListener('change', () => {
            const v = parseFloat(yawInput.value);
            plane.yaw = Number.isFinite(v) ? v : 0;
            updateCustomPlaneMeshesFromParams();
            recomputeRegionInfoAndHighlight();
            updateURLFromState();
          });

          pitchInput.addEventListener('change', () => {
            const v = parseFloat(pitchInput.value);
            plane.pitch = Number.isFinite(v) ? v : 0;
            updateCustomPlaneMeshesFromParams();
            recomputeRegionInfoAndHighlight();
            updateURLFromState();
          });

          delButton.addEventListener('click', () => {
            params.customPlanes.splice(index, 1);
            updateCustomPlaneMeshesFromParams();
            recomputeRegionInfoAndHighlight();
            rebuildCustomPlanesListUI();
            updateURLFromState();
          });

          controls.appendChild(yawInput);
          controls.appendChild(pitchInput);
          controls.appendChild(delButton);

          row.appendChild(label);
          row.appendChild(controls);
          customPlanesList.appendChild(row);
        });
      }

      addPlaneButton.addEventListener('click', () => {
        if (!params.customPlanes) params.customPlanes = [];
        params.customPlanes.push({ yaw: 0, pitch: 0, visible: true });
        updateCustomPlaneMeshesFromParams();
        recomputeRegionInfoAndHighlight();
        rebuildCustomPlanesListUI();
        updateURLFromState();
      });

      clearPlanesButton.addEventListener('click', () => {
        params.customPlanes = [];
        updateCustomPlaneMeshesFromParams();
        recomputeRegionInfoAndHighlight();
        rebuildCustomPlanesListUI();
        updateURLFromState();
      });

      function ensureCustomPlaneIndex(i) {
        if (!params.customPlanes) params.customPlanes = [];
        while (params.customPlanes.length <= i) {
          params.customPlanes.push({ yaw: 0, pitch: 0, visible: true });
        }
      }

      function updateCustomPlaneMeshesFromParams() {
        if (!params.customPlanes) params.customPlanes = [];

        if (!sourceBBox || crop.xmin == null) {
          // Just hide meshes if no geometry/bbox yet.
          for (const mesh of customPlaneMeshes) {
            mesh.visible = false;
          }
          clearRegionHighlight();
          return;
        }

        const cx = (crop.xmin + crop.xmax) / 2;
        const cy = (crop.ymin + crop.ymax) / 2;
        const cz = (crop.zmin + crop.zmax) / 2;
        const dx = Math.max(crop.xmax - crop.xmin, 1e-3);
        const dy = Math.max(crop.ymax - crop.ymin, 1e-3);
        const dz = Math.max(crop.zmax - crop.zmin, 1e-3);
        const maxSide = Math.max(dx, dy, dz);
        const scale = maxSide * 2.5;

        // Create / update meshes
        for (let i = 0; i < params.customPlanes.length; i++) {
          const plane = params.customPlanes[i];
          if (!Number.isFinite(plane.px)) plane.px = cx;
          if (!Number.isFinite(plane.py)) plane.py = cy;
          if (!Number.isFinite(plane.pz)) plane.pz = cz;
          let mesh = customPlaneMeshes[i];
          if (!mesh) {
            const geo = new THREE.PlaneGeometry(1, 1);
            const mat = new THREE.MeshBasicMaterial({
              color: CUSTOM_PLANE_COLORS[i % CUSTOM_PLANE_COLORS.length],
              transparent: true,
              opacity: 0.16,
              side: THREE.DoubleSide,
              depthWrite: false
            });
            mesh = new THREE.Mesh(geo, mat);
            mesh.name = 'CustomPlane_' + i;
            mesh.renderOrder = 2;
            mesh.userData.customPlaneIndex = i;
            scene.add(mesh);
            customPlaneMeshes[i] = mesh;
          } else if (mesh.material && mesh.material.color) {
            mesh.material.color.setHex(CUSTOM_PLANE_COLORS[i % CUSTOM_PLANE_COLORS.length]);
          }

          const yaw = THREE.MathUtils.degToRad(plane.yaw || 0);
          const pitch = THREE.MathUtils.degToRad(plane.pitch || 0);
          const normal = new THREE.Vector3(
            Math.sin(yaw) * Math.cos(pitch),
            Math.sin(pitch),
            Math.cos(yaw) * Math.cos(pitch)
          ).normalize();
          const q = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), normal);
          mesh.quaternion.copy(q);
          mesh.position.set(plane.px, plane.py, plane.pz);
          mesh.scale.set(scale, scale, 1);
          mesh.visible = !!params.showCustomPlanes && plane.visible !== false;
        }

        // Remove extra meshes
        for (let i = params.customPlanes.length; i < customPlaneMeshes.length; i++) {
          const mesh = customPlaneMeshes[i];
          if (mesh) {
            scene.remove(mesh);
            if (mesh.geometry) mesh.geometry.dispose();
            if (mesh.material) mesh.material.dispose();
          }
        }
        customPlaneMeshes.length = params.customPlanes.length;
      }

      function ensureMagicSpatialIndex(radius) {
        if (!pointGeometry || radius <= 0) return null;
        const posAttr = pointGeometry.getAttribute('position');
        if (!posAttr) return null;
        if (magicIndex && magicIndex.radius === radius && magicIndex.count === posAttr.count) {
          return magicIndex;
        }
        const cellSize = radius;
        const inv = 1 / cellSize;
        const map = new Map();
        const tmp = new THREE.Vector3();
        const count = posAttr.count;
        for (let i = 0; i < count; i++) {
          tmp.fromBufferAttribute(posAttr, i);
          const cx = Math.floor(tmp.x * inv);
          const cy = Math.floor(tmp.y * inv);
          const cz = Math.floor(tmp.z * inv);
          const key = cx + ',' + cy + ',' + cz;
          let bucket = map.get(key);
          if (!bucket) {
            bucket = [];
            map.set(key, bucket);
          }
          bucket.push(i);
        }
        magicIndex = {
          radius,
          radius2: radius * radius,
          cellSize,
          inv,
          map,
          count
        };
        return magicIndex;
      }

      function stepMagicJob() {
        if (!magicJob || !magicJob.running) return;
        const posAttr = pointGeometry && pointGeometry.getAttribute('position');
        if (!posAttr) {
          magicJob = null;
          magicCountEl.textContent = '-';
          return;
        }
        const { radius2, inv, map, visited, queue, group, tmpA, tmpB, totalPoints } = magicJob;
        const maxIters = 4000;
        let processed = 0;

        while (queue.length && processed < maxIters) {
          const i = queue.shift();
          group.push(i);
          tmpA.fromBufferAttribute(posAttr, i);
          const cx = Math.floor(tmpA.x * inv);
          const cy = Math.floor(tmpA.y * inv);
          const cz = Math.floor(tmpA.z * inv);
          for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
              for (let dz = -1; dz <= 1; dz++) {
                const key = (cx + dx) + ',' + (cy + dy) + ',' + (cz + dz);
                const bucket = map.get(key);
                if (!bucket) continue;
                for (let k = 0; k < bucket.length; k++) {
                  const j = bucket[k];
                  if (visited[j]) continue;
                  tmpB.fromBufferAttribute(posAttr, j);
                  const dxp = tmpB.x - tmpA.x;
                  const dyp = tmpB.y - tmpA.y;
                  const dzp = tmpB.z - tmpA.z;
                  const dist2 = dxp * dxp + dyp * dyp + dzp * dzp;
                  if (dist2 <= radius2) {
                    visited[j] = 1;
                    queue.push(j);
                  }
                }
              }
            }
          }
          processed++;
        }

        const visitedCount = group.length;
        const pct = totalPoints > 0 ? (visitedCount / totalPoints) * 100 : 0;
        magicCountEl.textContent =
          visitedCount.toLocaleString('en-US') +
          ' / ' +
          totalPoints.toLocaleString('en-US') +
          ' (' +
          pct.toFixed(1) +
          '%)';

        if (!queue.length) {
          magicJob.running = false;
          if (!group.length) {
            magicCountEl.textContent = '0 / ' + totalPoints.toLocaleString('en-US') + ' (0%)';
            return;
          }

          const min = new THREE.Vector3(+Infinity, +Infinity, +Infinity);
          const max = new THREE.Vector3(-Infinity, -Infinity, -Infinity);
          const tmp = new THREE.Vector3();
          for (let t = 0; t < group.length; t++) {
            const idx = group[t];
            tmp.fromBufferAttribute(posAttr, idx);
            min.min(tmp);
            max.max(tmp);
          }

          // store exact membership mask for cropping
          magicMask = visited;

          // Visualize Magic Volume as its own box
          ensureRegionHighlightObjects();
          smallRegionBox.set(min, max);
          smallRegionHelper.visible = true;
          const cx = (min.x + max.x) / 2;
          const cy = (min.y + max.y) / 2;
          const cz = (min.z + max.z) / 2;
          const sx = Math.max(max.x - min.x, 1e-4);
          const sy = Math.max(max.y - min.y, 1e-4);
          const sz = Math.max(max.z - min.z, 1e-4);
          regionMesh.position.set(cx, cy, cz);
          regionMesh.scale.set(sx, sy, sz);
          regionMaterial.clippingPlanes = [];
          regionMesh.visible = true;

          crop.xmin = min.x;
          crop.xmax = max.x;
          crop.ymin = min.y;
          crop.ymax = max.y;
          crop.zmin = min.z;
          crop.zmax = max.z;
          clampCropToBBox();
          updateCropPlanesFromState();
          updateCropInputsFromState();
          updateCustomPlaneMeshesFromParams();
          updateURLFromState();
        }
      }

      function runMagicVolumeFromSeed(seedIndex) {
        if (!pointGeometry || !sourceBBox) return;
        const radius = params.magicLength;
        if (!Number.isFinite(radius) || radius <= 0) {
          alert('Please set Magic Point Length to a value greater than zero first.');
          return;
        }
        const posAttr = pointGeometry.getAttribute('position');
        if (!posAttr) return;

        const index = ensureMagicSpatialIndex(radius);
        if (!index) return;
        const { radius2, inv, map } = index;

        const count = posAttr.count;
        const visited = new Uint8Array(count);
        const queue = [];
        const group = [];
        const tmpA = new THREE.Vector3();
        const tmpB = new THREE.Vector3();

        queue.push(seedIndex);
        visited[seedIndex] = 1;

        magicJob = {
          running: true,
          radius,
          radius2,
          inv,
          map,
          visited,
          queue,
          group,
          tmpA,
          tmpB,
          totalPoints: count
        };
        magicCountEl.textContent = '0 / ' + count.toLocaleString('en-US') + ' (0%)';
        params.magicSeedIndex = seedIndex;
        updateURLFromState();
      }

      function recomputeRegionInfoAndHighlight() {
        if (!pointGeometry || !sourceBBox || crop.xmin == null) {
          clearRegionHighlight();
          return null;
        }
        if (!params.customPlanes || !params.customPlanes.length) {
          clearRegionHighlight();
          return null;
        }

        const posAttr = pointGeometry.getAttribute('position');
        if (!posAttr) {
          clearRegionHighlight();
          return null;
        }

        const center = new THREE.Vector3(
          (crop.xmin + crop.xmax) / 2,
          (crop.ymin + crop.ymax) / 2,
          (crop.zmin + crop.zmax) / 2
        );

        const normals = [];
        const planePoints = [];
        for (const plane of params.customPlanes) {
          const yaw = THREE.MathUtils.degToRad(plane.yaw || 0);
          const pitch = THREE.MathUtils.degToRad(plane.pitch || 0);
          const n = new THREE.Vector3(
            Math.sin(yaw) * Math.cos(pitch),
            Math.sin(pitch),
            Math.cos(yaw) * Math.cos(pitch)
          ).normalize();
          normals.push(n);
          const px = Number.isFinite(plane.px) ? plane.px : center.x;
          const py = Number.isFinite(plane.py) ? plane.py : center.y;
          const pz = Number.isFinite(plane.pz) ? plane.pz : center.z;
          planePoints.push(new THREE.Vector3(px, py, pz));
        }

        const planeCount = normals.length;
        const regionMap = new Map();
        const tmp = new THREE.Vector3();

        const planeDots = normals.map((n, i) => n.dot(planePoints[i]));

        for (let i = 0; i < posAttr.count; i++) {
          tmp.fromBufferAttribute(posAttr, i);
          const insideBox =
            tmp.x >= crop.xmin && tmp.x <= crop.xmax &&
            tmp.y >= crop.ymin && tmp.y <= crop.ymax &&
            tmp.z >= crop.zmin && tmp.z <= crop.zmax;
          if (!insideBox) continue;

          let key = '';
          for (let j = 0; j < planeCount; j++) {
            const d = normals[j].dot(tmp) - planeDots[j];
            key += d >= 0 ? '1' : '0';
          }
          let r = regionMap.get(key);
          if (!r) {
            r = {
              min: new THREE.Vector3().copy(tmp),
              max: new THREE.Vector3().copy(tmp),
              count: 0
            };
            regionMap.set(key, r);
          } else {
            r.min.min(tmp);
            r.max.max(tmp);
          }
          r.count++;
        }

        if (!regionMap.size) {
          clearRegionHighlight();
          return null;
        }

        let bestKey = null;
        let bestRegion = null;
        let bestScore = -Infinity;
        let bestCount = -Infinity;
        const corner = new THREE.Vector3();
        for (const [key, r] of regionMap.entries()) {
          const mn = r.min;
          const mx = r.max;
          let intersectCount = 0;
          for (let j = 0; j < planeCount; j++) {
            const n = normals[j];
            const pDot = planeDots[j];
            let minDot = Infinity;
            let maxDot = -Infinity;
            for (const x of [mn.x, mx.x]) {
              for (const y of [mn.y, mx.y]) {
                for (const z of [mn.z, mx.z]) {
                  corner.set(x, y, z);
                  const d = n.dot(corner);
                  if (d < minDot) minDot = d;
                  if (d > maxDot) maxDot = d;
                }
              }
            }
            if (minDot <= pDot && pDot <= maxDot) {
              intersectCount++;
            }
          }
          const score = intersectCount;
          if (score > bestScore || (score === bestScore && r.count > bestCount)) {
            bestScore = score;
            bestCount = r.count;
            bestKey = key;
            bestRegion = r;
          }
        }

        if (!bestRegion) {
          clearRegionHighlight();
          return null;
        }

        ensureRegionHighlightObjects();
        // Update debug box but keep it hidden by default
        smallRegionBox.set(bestRegion.min, bestRegion.max);
        smallRegionHelper.visible = false;

        const dx = crop.xmax - crop.xmin;
        const dy = crop.ymax - crop.ymin;
        const dz = crop.zmax - crop.zmin;
        regionMesh.position.copy(center);
        regionMesh.scale.set(Math.max(dx, 1e-3), Math.max(dy, 1e-3), Math.max(dz, 1e-3));

        const planes = [];
        // Crop-box planes (keep inside box)
        planes.push(new THREE.Plane(new THREE.Vector3(1, 0, 0), -crop.xmin));
        planes.push(new THREE.Plane(new THREE.Vector3(-1, 0, 0), crop.xmax));
        planes.push(new THREE.Plane(new THREE.Vector3(0, 1, 0), -crop.ymin));
        planes.push(new THREE.Plane(new THREE.Vector3(0, -1, 0), crop.ymax));
        planes.push(new THREE.Plane(new THREE.Vector3(0, 0, 1), -crop.zmin));
        planes.push(new THREE.Plane(new THREE.Vector3(0, 0, -1), crop.zmax));

        // Custom planes to isolate selected region
        for (let j = 0; j < planeCount; j++) {
          const bit = bestKey[j] === '1';
          const n = normals[j].clone();
          const p0 = planePoints[j];
          if (!bit) n.negate();
          const constant = -n.dot(p0);
          planes.push(new THREE.Plane(n, constant));
        }

        regionMaterial.clippingPlanes = planes;
        regionMesh.visible = true;

        lastRegionInfo = {
          normals: normals.map((n) => n.clone()),
          planePoints: planePoints.map((p) => p.clone()),
          planeCount,
          selectedKey: bestKey
        };
        return lastRegionInfo;
      }

      resetCropButton.addEventListener('click', () => {
        if (!sourceBBox) return;
        crop.xmin = sourceBBox.min.x;
        crop.xmax = sourceBBox.max.x;
        crop.ymin = sourceBBox.min.y;
        crop.ymax = sourceBBox.max.y;
        crop.zmin = sourceBBox.min.z;
        crop.zmax = sourceBBox.max.z;
        clampCropToBBox();
        updateCropPlanesFromState();
        updateCropInputsFromState();
        updateCustomPlaneMeshesFromParams();
        clearMagicState();
        recomputeRegionInfoAndHighlight();
        updateURLFromState();
      });

      function frameCameraToBBox() {
        if (!sourceBBox) return;
        const center = sourceBBox.getCenter(new THREE.Vector3());
        const size = sourceBBox.getSize(new THREE.Vector3());
        const maxSide = Math.max(size.x, size.y, size.z);
        const radius = maxSide * 1.2 || 1;
        controls.target.copy(center);
        camera.position.copy(center).add(new THREE.Vector3(radius, radius * 0.6, radius * 1.2));
        camera.near = radius / 100;
        camera.far = radius * 20;
        camera.updateProjectionMatrix();
        controls.update();
      }

      function clearCurrentPointCloud() {
        if (pointCloud) {
          scene.remove(pointCloud);
          pointCloud.geometry.dispose();
          pointCloud.material.dispose();
          pointCloud = null;
          pointGeometry = null;
          pointMaterial = null;
          sourceBBox = null;
          hasPointColors = false;
        }
        clearMagicState();
      }

      function onPLYGeometryLoaded(geometry, name) {
        clearCurrentPointCloud();

        geometry.computeBoundingBox();
        sourceBBox = geometry.boundingBox.clone();
        const posAttr = geometry.getAttribute('position');
        const count = posAttr ? posAttr.count : 0;

        hasPointColors = !!geometry.getAttribute('color');

        const material = new THREE.PointsMaterial({
          size: params.pointSize,
          sizeAttenuation: true,
          vertexColors: hasPointColors,
          color: 0xffffff
        });

        const points = new THREE.Points(geometry, material);
        pointCloud = points;
        pointGeometry = geometry;
        pointMaterial = material;
        sourceFileName = name;

        scene.add(points);
        frameCameraToBBox();
        initCropFromBBox();

        // If Magic Volume seed was provided via URL/preset, re-run Magic Volume
        if (params.magicSeedIndex != null) {
          const seed = params.magicSeedIndex | 0;
          if (seed >= 0 && posAttr && seed < posAttr.count) {
            runMagicVolumeFromSeed(seed);
          } else {
            params.magicSeedIndex = null;
          }
        }

        fileNameEl.textContent = name || 'Unknown';
        pointCountEl.textContent = count.toLocaleString('en-US');
        downloadButton.disabled = false;
        resetCropButton.disabled = false;
        presetButton.disabled = false;
        dropHint.style.display = 'none';
      }

      function handleDropFile(file) {
        if (!file) return;
        if (!file.name.toLowerCase().endsWith('.ply')) {
          alert('Only .ply point cloud files are supported at the moment.');
          return;
        }
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const arrayBuffer = e.target.result;
            const geometry = plyLoader.parse(arrayBuffer);
            onPLYGeometryLoaded(geometry, file.name);
          } catch (err) {
            console.error(err);
            alert('An error occurred while reading the PLY file.');
          }
        };
        reader.readAsArrayBuffer(file);
      }

      function setupDragAndDrop() {
        const prevent = (e) => {
          e.preventDefault();
          e.stopPropagation();
        };

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach((eventName) => {
          window.addEventListener(eventName, prevent);
        });

        window.addEventListener('dragenter', () => {
          dropOverlay.style.display = 'flex';
        });
        window.addEventListener('dragleave', (e) => {
          if (e.target === document || e.target === window) {
            dropOverlay.style.display = 'none';
          }
        });
        window.addEventListener('drop', (e) => {
          dropOverlay.style.display = 'none';
          const dt = e.dataTransfer;
          if (!dt || !dt.files || !dt.files.length) return;
          const file = dt.files[0];
          handleDropFile(file);
        });
      }

      function buildPresetJSON() {
        if (!sourceBBox) return null;
        return {
          version: 1,
          sourceFile: sourceFileName || null,
          pointSize: params.pointSize,
          invertCrop: !!params.invertCrop,
          showCropBox: !!params.showCropBox,
          magicLength: params.magicLength,
          magicSeedIndex: params.magicSeedIndex ?? null,
          crop: {
            xmin: crop.xmin,
            xmax: crop.xmax,
            ymin: crop.ymin,
            ymax: crop.ymax,
            zmin: crop.zmin,
            zmax: crop.zmax
          },
          customPlanes: (params.customPlanes || []).map((plane) => ({
            yaw: plane.yaw || 0,
            pitch: plane.pitch || 0,
            px: Number.isFinite(plane.px) ? plane.px : (crop.xmin + crop.xmax) / 2,
            py: Number.isFinite(plane.py) ? plane.py : (crop.ymin + crop.ymax) / 2,
            pz: Number.isFinite(plane.pz) ? plane.pz : (crop.zmin + crop.zmax) / 2,
            visible: plane.visible !== false
          })),
          sourceBBox: {
            min: { x: sourceBBox.min.x, y: sourceBBox.min.y, z: sourceBBox.min.z },
            max: { x: sourceBBox.max.x, y: sourceBBox.max.y, z: sourceBBox.max.z }
          }
        };
      }

      function buildCroppedPLYText() {
        if (!pointGeometry || !sourceBBox) return null;
        const posAttr = pointGeometry.getAttribute('position');
        if (!posAttr) return null;
        const colorAttr = pointGeometry.getAttribute('color');

        const keptIndices = [];
        const tmp = new THREE.Vector3();

        const useMagic = magicMask && magicMask.length === posAttr.count;

        const useCustom = params.customPlanes && params.customPlanes.length > 0;
        let regionInfo = null;
        if (useCustom && !useMagic) {
          regionInfo = lastRegionInfo || recomputeRegionInfoAndHighlight();
        }

        const normals = regionInfo ? regionInfo.normals : null;
        const planePoints = regionInfo ? regionInfo.planePoints : null;
        const planeCount = regionInfo ? regionInfo.planeCount : 0;

        for (let i = 0; i < posAttr.count; i++) {
          tmp.fromBufferAttribute(posAttr, i);
          if (useMagic) {
            const inGroup = !!magicMask[i];
            const keepMagic = params.invertCrop ? !inGroup : inGroup;
            if (keepMagic) keptIndices.push(i);
            continue;
          }
          const insideBox =
            tmp.x >= crop.xmin && tmp.x <= crop.xmax &&
            tmp.y >= crop.ymin && tmp.y <= crop.ymax &&
            tmp.z >= crop.zmin && tmp.z <= crop.zmax;

          let keep = false;

          if (useCustom && regionInfo && normals && planePoints && planeCount > 0) {
            let isSelected = false;
            if (insideBox) {
              let key = '';
              for (let j = 0; j < planeCount; j++) {
                const n = normals[j];
                const p0 = planePoints[j];
                const d = n.dot(tmp) - n.dot(p0);
                key += d >= 0 ? '1' : '0';
              }
              isSelected = (key === regionInfo.selectedKey);
            }
            keep = params.invertCrop ? !isSelected : isSelected;
          } else {
            keep = params.invertCrop ? !insideBox : insideBox;
          }

          if (keep) keptIndices.push(i);
        }

        const n = keptIndices.length;
        if (!n) {
          let msg;
          if (useMagic) {
            msg = params.invertCrop
              ? 'No points exist outside the Magic Volume group.'
              : 'No points exist inside the Magic Volume group.';
          } else if (useCustom) {
            msg = params.invertCrop
              ? 'No points exist outside the selected smallest custom-plane region.'
              : 'There are no points inside the region defined by custom planes.';
          } else {
            msg = params.invertCrop
              ? 'There are no points outside the crop box.'
              : 'There are no points inside the crop box.';
          }
          alert(msg);
          return null;
        }

        const lines = [];
        lines.push('ply');
        lines.push('format ascii 1.0');
        lines.push('comment generated by point-cloud-cropper');
        lines.push('element vertex ' + n);
        lines.push('property float x');
        lines.push('property float y');
        lines.push('property float z');
        const hasColor = !!colorAttr;
        if (hasColor) {
          lines.push('property uchar red');
          lines.push('property uchar green');
          lines.push('property uchar blue');
        }
        lines.push('end_header');

        for (let k = 0; k < n; k++) {
          const idx = keptIndices[k];
          tmp.fromBufferAttribute(posAttr, idx);
          let line = tmp.x + ' ' + tmp.y + ' ' + tmp.z;
          if (hasColor) {
            const r = colorAttr.getX(idx);
            const g = colorAttr.getY(idx);
            const b = colorAttr.getZ(idx);
            const rr = Math.round(r * (r <= 1 ? 255 : 1));
            const gg = Math.round(g * (g <= 1 ? 255 : 1));
            const bb = Math.round(b * (b <= 1 ? 255 : 1));
            line += ' ' + rr + ' ' + gg + ' ' + bb;
          }
          lines.push(line);
        }

        return lines.join('\n');
      }

      function downloadBlob(content, filename, mimeType) {
        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      presetButton.addEventListener('click', () => {
        if (!sourceBBox) {
          alert('Please load a point cloud first.');
          return;
        }
        const preset = buildPresetJSON();
        if (!preset) return;
        const presetJSON = JSON.stringify(preset, null, 2);
        downloadBlob(presetJSON, 'preset.json', 'application/json');
      });

      downloadButton.addEventListener('click', () => {
        if (!pointGeometry || !sourceBBox) {
          alert('Please load a point cloud first.');
          return;
        }

        const plyText = buildCroppedPLYText();
        if (!plyText) return;

        const baseName = (sourceFileName || 'cloud').replace(/\.ply$/i, '');
        const plyName = 'cropped_' + baseName + '.ply';

        downloadBlob(plyText, plyName, 'application/octet-stream');
      });

      function animate() {
        requestAnimationFrame(animate);
        if (typeof stepMagicJob === 'function') {
          stepMagicJob();
        }
        controls.update();
        renderer.render(scene, camera);
      }
      animate();

      // initial sync for custom planes UI/meshes
      rebuildCustomPlanesListUI();
      updateCustomPlaneMeshesFromParams();
      recomputeRegionInfoAndHighlight();

       // keyboard shortcuts for custom plane transform mode
      window.addEventListener('keydown', (e) => {
        if (!transformControls || !transformControls.object) return;
        if (currentSelectionType !== 'custom') return;
        if (e.key === 'r' || e.key === 'R') {
          transformControls.setMode('rotate');
        } else if (e.key === 't' || e.key === 'T') {
          transformControls.setMode('translate');
        }
      });

      setupDragAndDrop();
      updateURLFromState();
    </script>
  </body>
</html>
